require('dotenv').config()
console.log('[boot] server.js loaded')
process.on('beforeExit', (code) => console.log('[lifecycle] beforeExit', code))
process.on('exit', (code) => console.log('[lifecycle] exit', code))
process.on('uncaughtException', (err) => { console.error('[lifecycle] uncaughtException', err); process.exit(1) })
process.on('unhandledRejection', (reason) => { console.error('[lifecycle] unhandledRejection', reason) })
const express = require('express')
const http = require('http')
const socketIo = require('socket.io')
const cors = require('cors')
const bcrypt = require('bcryptjs')
const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3')
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner')
const { connectMongo } = require('./db/mongo')
const Conversation = require('./models/Conversation')
const Message = require('./models/Message')

// ÎùºÏö∞ÌÑ∞ import (ÏµúÏÜå Í∏∞Îä•Ïö© DB ÏßÅÏ†ë ÏÇ¨Ïö©)
const {
  testConnection,
  findUserByEmail,
  createUser,
  createDog,
  getDogsByUserId,
  deleteDogByIdOwner,
  createSitterPosting,
  getAllSitters,
  getSitterByUserId,
  getBookingsByOwnerId,
  getBookingsBySitterId,
  createBooking,
  createJobPosting,
  getAllActiveOwnerJobs,
  updateJobPostingStatus,
  pool,
} = require('./config/database-minimal')

const app = express()
console.log('[boot] express created')
const server = http.createServer(app)

// CORS ÏÑ§Ï†ï
app.use(cors({
  origin: "*",
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
  credentials: true
}))

const io = socketIo(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
})

// AWS ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ï†ï
const REGION = process.env.AWS_REGION || 'ap-northeast-2'
const MESSAGES_TABLE = process.env.MESSAGES_TABLE || 'PetBuddyMessages'
const s3Bucket = process.env.S3_BUCKET || 'pet-buddy-uploads'

const s3Config = {
  region: REGION,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  }
}

const s3 = new S3Client(s3Config)

console.log('üîß S3 ÏÑ§Ï†ï:', {
  region: REGION,
  bucket: s3Bucket,
  hasCredentials: !!(process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY)
})

// Base64 Ïù¥ÎØ∏ÏßÄÎ•º S3Ïóê ÏóÖÎ°úÎìúÌïòÎäî Ìï®Ïàò
async function uploadBase64ToS3(base64Data, fileName) {
  try {
    // data:image/jpeg;base64,/9j/4AAQ... ÌòïÌÉúÏóêÏÑú base64 Î∂ÄÎ∂ÑÎßå Ï∂îÏ∂ú
    const base64Match = base64Data.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/)
    if (!base64Match) {
      throw new Error('Invalid base64 format')
    }
    
    const contentType = base64Match[1]
    const base64Content = base64Match[2]
    const buffer = Buffer.from(base64Content, 'base64')
    
    const key = `test0812/${Date.now()}_${fileName || 'photo.jpg'}`
    const command = new PutObjectCommand({
      Bucket: s3Bucket,
      Key: key,
      Body: buffer,
      ContentType: contentType
    })
    
    await s3.send(command)
    const publicUrl = `https://${s3Bucket}.s3.${REGION}.amazonaws.com/${key}`
    
    console.log('‚úÖ S3 ÏóÖÎ°úÎìú ÏÑ±Í≥µ:', publicUrl)
    return publicUrl
  } catch (error) {
    console.error('‚ùå S3 ÏóÖÎ°úÎìú Ïã§Ìå®:', error)
    throw error
  }
}

// Î°úÏª¨ Ï∫êÏãú(ÏÑ†ÌÉù): ÏµúÍ∑º ÎåÄÌôîÎ∞© Î©îÏãúÏßÄ Ï∫êÏãú (MongoÎ°ú Ïù¥Ï†ÑÌï¥ÎèÑ Ìï´ Ï∫êÏãúÎ°ú Ïú†ÏßÄ Í∞ÄÎä•)
const messageHistory = new Map()
const activeUsers = new Map()

app.use(express.json({ limit: '10mb' }))
app.use(express.urlencoded({ extended: true }))

// ÏöîÏ≤≠ Î°úÍπÖ ÎØ∏Îì§Ïõ®Ïñ¥ (Í∞ÑÏÜåÌôî)
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`)
  next()
})

// === ÏµúÏÜå Í∏∞Îä• Auth ===
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body || {}
  try {
    if (!email || !password) return res.status(400).json({ success: false, message: 'Ïù¥Î©îÏùº/ÎπÑÎ∞ÄÎ≤àÌò∏ ÌïÑÏöî' })
    const user = await findUserByEmail(email)
    if (!user) return res.status(401).json({ success: false, message: 'ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' })

    const stored = user.password_hash ?? user.password ?? ''
    let isMatch = false
    try {
      // bcrypt Ìï¥Ïãú ÌòïÌÉúÎ©¥ ÎπÑÍµê, ÏïÑÎãàÎ©¥ Î¨∏ÏûêÏó¥ ÎπÑÍµê
      if (typeof stored === 'string' && stored.startsWith('$2')) {
        isMatch = await bcrypt.compare(String(password), stored)
      } else {
        isMatch = String(stored) === String(password)
      }
    } catch (_) {
      isMatch = String(stored) === String(password)
    }

    if (!isMatch) {
      return res.status(401).json({ success: false, message: 'ÎπÑÎ∞ÄÎ≤àÌò∏ Î∂àÏùºÏπò' })
    }

    return res.json({ success: true, data: { user: { id: user.id || user.user_id, email: user.email, fullName: user.full_name || user.email.split('@')[0], phone: user.phone || user.phone_number }, token: 'dev-token' } })
  } catch (e) {
    console.error('login error', e)
    res.status(500).json({ success: false, message: 'Î°úÍ∑∏Ïù∏ Ïã§Ìå®' })
  }
})

app.post('/api/auth/register', async (req, res) => {
  const { email, password, phone_number } = req.body || {}
  try {
    if (!email || !password) return res.status(400).json({ success: false, message: 'Ïù¥Î©îÏùº/ÎπÑÎ∞ÄÎ≤àÌò∏ ÌïÑÏöî' })
    const exist = await findUserByEmail(email)
    if (exist) return res.status(400).json({ success: false, message: 'Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Ïù¥Î©îÏùºÏûÖÎãàÎã§.' })
    // DB Ïä§ÌÇ§ÎßàÏóê Îî∞Îùº password_hash ÎòêÎäî password Ïª¨ÎüºÎ°ú Ï†ÄÏû•Îê©ÎãàÎã§
    const result = await createUser({ email, password_hash: password, phone_number: phone_number || null })
    return res.json({ success: true, data: { user: { id: result.userId, email, fullName: email.split('@')[0], phone: phone_number || null }, token: 'dev-token' } })
  } catch (e) {
    console.error('register error', e)
    res.status(500).json({ success: false, message: e?.message || 'ÌöåÏõêÍ∞ÄÏûÖ Ïã§Ìå®' })
  }
})

// === Dogs ===
// ÌÖåÏù¥Î∏î Íµ¨Ï°∞ ÌôïÏù∏ API (ÎîîÎ≤ÑÍ∑∏Ïö©)
app.get('/api/debug/dogs-table', async (req, res) => {
  try {
    const { pool } = require('./config/database-minimal')
    const [columns] = await pool.execute('SHOW COLUMNS FROM dogs')
    res.json({ 
      success: true, 
      columns: columns.map(col => ({
        Field: col.Field,
        Type: col.Type,
        Null: col.Null,
        Key: col.Key,
        Default: col.Default
      }))
    })
  } catch (e) {
    console.error('table structure error', e)
    res.status(500).json({ success: false, message: 'ÌÖåÏù¥Î∏î Íµ¨Ï°∞ Ï°∞Ìöå Ïã§Ìå®' })
  }
})

app.get('/api/dogs/user/:userId', async (req, res) => {
  try {
    console.log('üîç Fetching dogs for user:', req.params.userId)
    const dogs = await getDogsByUserId(req.params.userId)
    console.log('üì§ Returning dogs:', dogs.map(dog => ({ id: dog.id, name: dog.name, dbti: dog.dbti })))
    res.json({ success: true, dogs })
  } catch (e) {
    console.error('dogs list error', e)
    res.status(500).json({ success: false, message: 'Í∞ïÏïÑÏßÄ Ï°∞Ìöå Ïã§Ìå®' })
  }
})

app.post('/api/dogs', async (req, res) => {
  const { user_id, name, profile_image_url, breed, personality, dbti, birth_date, special_notes } = req.body || {}
  if (!user_id || !name) {
    return res.status(400).json({ success: false, message: 'ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ (user_id, name)' })
  }
  try {
    console.log('üê∂ Í∞ïÏïÑÏßÄ Îì±Î°ù ÏöîÏ≤≠:', { user_id, name, breed, personality, dbti, birth_date, hasPhoto: !!profile_image_url })
    
    let finalImageUrl = profile_image_url
    
    // base64 Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏûàÏúºÎ©¥ S3Ïóê ÏóÖÎ°úÎìú (AWS ÏûêÍ≤©Ï¶ùÎ™ÖÏù¥ ÏûàÏùÑ ÎïåÎßå)
    if (profile_image_url && profile_image_url.startsWith('data:')) {
      console.log('üì∏ base64 Ïù¥ÎØ∏ÏßÄ Í∞êÏßÄÎê®')
      if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
        console.log('üì∏ S3 ÏóÖÎ°úÎìú ÏãúÏûë...')
        try {
          finalImageUrl = await uploadBase64ToS3(profile_image_url, `${name}_${Date.now()}.jpg`)
          console.log('‚úÖ Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏôÑÎ£å:', finalImageUrl)
        } catch (uploadError) {
          console.error('‚ùå Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïã§Ìå®:', uploadError)
          // Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïã§Ìå®Ìï¥ÎèÑ Í∞ïÏïÑÏßÄ Îì±Î°ùÏùÄ Í≥ÑÏÜç ÏßÑÌñâ (base64 Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©)
          finalImageUrl = profile_image_url
        }
      } else {
        console.log('‚ö†Ô∏è AWS ÏûêÍ≤©Ï¶ùÎ™Ö ÏóÜÏùå, base64 Ïù¥ÎØ∏ÏßÄ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©')
        finalImageUrl = profile_image_url
      }
    }
    
    const result = await createDog({ user_id, name, profile_image_url: finalImageUrl, breed, personality, dbti, birth_date, special_notes })
    res.json({ success: true, dog: { id: result.dogId, user_id, name, profile_image_url: finalImageUrl, breed, personality, dbti, birth_date, special_notes } })
  } catch (e) {
    console.error('dog create error', e)
    res.status(500).json({ success: false, message: e?.message || 'Î∞òÎ†§Í≤¨ Îì±Î°ù Ïã§Ìå®' })
  }
})

// Í∞ïÏïÑÏßÄ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏ API
app.patch('/api/dogs/:dogId', async (req, res) => {
  const { dogId } = req.params
  const { user_id, name, breed, personality, dbti, notes } = req.body || {}
  
  if (!dogId || !user_id) {
    return res.status(400).json({ success: false, message: 'ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ (dogId, user_id)' })
  }
  
  try {
    console.log('üîÑ Updating dog:', { dogId, user_id, name, breed, dbti })
    
    const { pool } = require('./config/database-minimal')
    
    // ÌÖåÏù¥Î∏î Íµ¨Ï°∞ ÌôïÏù∏
    const [columns] = await pool.execute('SHOW COLUMNS FROM dogs')
    const columnNames = columns.map(col => col.Field)
    
    // DBTI Ïª¨Îüº ÌôïÏù∏
    let dbtiColumn = 'dbti'
    if (columnNames.includes('dbtiType')) {
      dbtiColumn = 'dbtiType'
    } else if (columnNames.includes('dbti_type')) {
      dbtiColumn = 'dbti_type'
    } else if (!columnNames.includes('dbti')) {
      // dbti Ïª¨Îüº Ï∂îÍ∞Ä
      await pool.execute('ALTER TABLE dogs ADD COLUMN dbti VARCHAR(20) DEFAULT NULL')
    }
    
    const updates = []
    const values = []
    
    if (name) { updates.push('name = ?'); values.push(name) }
    if (breed) { updates.push('breed = ?'); values.push(breed) }
    if (personality) { updates.push('personality = ?'); values.push(personality) }
    if (dbti) { updates.push(`${dbtiColumn} = ?`); values.push(dbti) }
    if (notes !== undefined) { updates.push('notes = ?'); values.push(notes) }
    
    if (updates.length > 0) {
      values.push(dogId, user_id)
      const query = `UPDATE dogs SET ${updates.join(', ')}, updated_at = NOW() WHERE id = ? AND owner_id = ?`
      console.log('üîÑ Update query:', query, values)
      
      const [result] = await pool.execute(query, values)
      if (result.affectedRows === 0) {
        return res.status(404).json({ success: false, message: 'Í∞ïÏïÑÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§' })
      }
      console.log('‚úÖ Dog updated successfully')
    }
    
    res.json({ success: true, message: 'Í∞ïÏïÑÏßÄ Ï†ïÎ≥¥Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§' })
  } catch (e) {
    console.error('dog update error', e)
    res.status(500).json({ success: false, message: 'Í∞ïÏïÑÏßÄ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®' })
  }
})

app.delete('/api/dogs/:dogId', async (req, res) => {
  const { dogId } = req.params
  const { user_id } = req.query
  if (!dogId || !user_id) return res.status(400).json({ success: false, message: 'ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ (dogId, user_id)' })
  try {
    const result = await deleteDogByIdOwner(dogId, String(user_id))
    if (result.success) return res.json({ success: true })
    return res.status(404).json({ success: false, message: 'ÎåÄÏÉÅ ÏóÜÏùå' })
  } catch (e) {
    console.error('dog delete error', e)
    res.status(500).json({ success: false, message: 'Î∞òÎ†§Í≤¨ ÏÇ≠Ï†ú Ïã§Ìå®' })
  }
})

// === Sitter postings ===
app.get('/api/sitter-postings', async (_req, res) => {
  try {
    // ÌôúÏÑ± Í≥µÍ≥†Îßå Î∞òÌôò
    const [rows] = await require('mysql2/promise').createPool(require('./config/database-minimal').dbConfig)
      .execute(`SELECT * FROM sitter_postings WHERE status = 'active' ORDER BY created_at DESC`)
    res.json({ success: true, posts: rows })
  } catch (e) {
    console.error('sitter postings list error', e)
    res.status(500).json({ success: false, message: 'ÏãúÌÑ∞ Í≥µÍ≥† Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®' })
  }
})

// ÏãúÌÑ∞ Í≥µÍ≥† ÎπÑÌôúÏÑ±Ìôî(ÏòàÏïΩ ÌõÑ Ïà®ÍπÄ)
app.post('/api/sitter-postings/:postId/close', async (req, res) => {
  const { postId } = req.params
  try {
    const pool = require('mysql2/promise').createPool(require('./config/database-minimal').dbConfig)
    const [result] = await pool.execute(`UPDATE sitter_postings SET status='closed' WHERE post_id = ?`, [postId])
    return res.json({ success: (result.affectedRows ?? 0) > 0 })
  } catch (e) {
    console.error('sitter posting close error', e)
    res.status(500).json({ success: false, message: 'ÏãúÌÑ∞ Í≥µÍ≥† ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïã§Ìå®' })
  }
})

// === Owner jobs ===
app.get('/api/jobs', async (_req, res) => {
  try {
    const jobs = await getAllActiveOwnerJobs()
    res.json({ success: true, jobs })
  } catch (e) {
    console.error('jobs list error', e)
    res.status(500).json({ success: false, message: 'Í≥µÍ≥† Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®' })
  }
})

app.post('/api/jobs', async (req, res) => {
  const { owner_id, dog_id, title, description, location, start_date, end_date, status } = req.body || {}
  if (!owner_id || !dog_id || !title || !start_date || !end_date) {
    return res.status(400).json({ success: false, message: 'ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ (owner_id, dog_id, title, start_date, end_date)' })
  }
  try {
    const result = await createJobPosting({ owner_id, dog_id, title, description, location, start_date, end_date, status })
    res.json({ success: true, job_id: result.jobId })
  } catch (e) {
    console.error('job create error', e)
    res.status(500).json({ success: false, message: 'Í≥µÍ≥† ÏÉùÏÑ± Ïã§Ìå®' })
  }
})

app.delete('/api/jobs/:jobId', async (req, res) => {
  const { jobId } = req.params
  try {
    const result = await updateJobPostingStatus(jobId, 'closed')
    if (result.success) return res.json({ success: true })
    return res.status(404).json({ success: false, message: 'ÎåÄÏÉÅ ÏóÜÏùå' })
  } catch (e) {
    console.error('job delete error', e)
    res.status(500).json({ success: false, message: 'Í≥µÍ≥† Ï∑®ÏÜå Ïã§Ìå®' })
  }
})
app.post('/api/sitter-postings', async (req, res) => {
  const { sitter_id, title, description, location, available_from, available_to, status } = req.body || {}
  if (!sitter_id || !title || !available_from || !available_to) {
    return res.status(400).json({ success: false, message: 'ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ (sitter_id, title, available_from, available_to)' })
  }
  try {
    const result = await createSitterPosting({ sitter_id, title, description, location, available_from, available_to, status })
    res.json({ success: true, post_id: result.postId })
  } catch (e) {
    console.error('sitter posting create error', e)
    res.status(500).json({ success: false, message: e?.message || 'ÏãúÌÑ∞ Í≥µÍ≥† ÏÉùÏÑ± Ïã§Ìå®' })
  }
})

// === AI ÌíàÏ¢Ö Î∂ÑÏÑù ===
app.post('/api/dogs/:dogId/analyze-breed', async (req, res) => {
  const { dogId } = req.params;
  const { imageUrl } = req.body;
  
  if (!dogId || !imageUrl) {
    return res.status(400).json({ 
      success: false, 
      error: 'ÌïÑÏàò ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§. (dogId, imageUrl)' 
    });
  }

  try {
    console.log(`ü§ñ AI ÌíàÏ¢Ö Î∂ÑÏÑù ÏöîÏ≤≠: dogId=${dogId}, imageUrl=${imageUrl}`);
    
    // AWS Lambda Ìï®Ïàò Ìò∏Ï∂ú
    const AWS = require('aws-sdk');
    const lambda = new AWS.Lambda({
      region: process.env.AWS_REGION || 'ap-northeast-2'
    });

    // Lambda Ìï®ÏàòÏóê Ï†ÑÎã¨Ìï† ÌéòÏù¥Î°úÎìú
    const lambdaPayload = {
      file_name: `temp_analysis_${Date.now()}.jpg`,
      dog_id: dogId,
      user_id: 'temp-user',
      image_data: imageUrl // Base64 Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞
    };

    console.log('üöÄ Lambda Ìï®Ïàò Ìò∏Ï∂ú Ï§ë...');
    
    const lambdaParams = {
      FunctionName: process.env.LAMBDA_FUNCTION_NAME || 'pet_breed_analyzer',
      Payload: JSON.stringify(lambdaPayload)
    };

    const lambdaResult = await lambda.invoke(lambdaParams).promise();
    
    if (lambdaResult.StatusCode === 200) {
      const responsePayload = JSON.parse(lambdaResult.Payload);
      
      if (responsePayload.statusCode === 200) {
        const analysisResult = JSON.parse(responsePayload.body);
        console.log('‚úÖ Lambda Ìï®Ïàò Ïã§Ìñâ ÏÑ±Í≥µ:', analysisResult);
        
        res.json({
          success: true,
          data: analysisResult
        });
      } else {
        console.error('‚ùå Lambda Ìï®Ïàò Ïò§Î•ò:', responsePayload);
        throw new Error(responsePayload.body || 'Lambda Ìï®Ïàò Ïã§Ìñâ Ïã§Ìå®');
      }
    } else {
      throw new Error(`Lambda Ìï®Ïàò Ìò∏Ï∂ú Ïã§Ìå®: StatusCode ${lambdaResult.StatusCode}`);
    }

  } catch (error) {
    console.error('‚ùå AI ÌíàÏ¢Ö Î∂ÑÏÑù Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      error: 'ÌíàÏ¢Ö Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

// Í∏∞Î≥∏ ÏóîÎìúÌè¨Ïù∏Ìä∏
app.get('/', (req, res) => {
  res.json({ 
    message: 'Pet Buddy Server is running!',
    version: '1.0.0',
    endpoints: {
      auth: '/api/auth',
      dogs: '/api/dogs',
      pets: '/api/pets', // ÏÉàÎ°ú Ï∂îÍ∞Ä
      bookings: '/api/bookings',
      sitters: '/api/sitters',
      chat: '/api/conversations'
    }
  })
})

// === Pet Í¥ÄÎ¶¨ (DogsÏôÄ ÎèôÏùºÌïòÏßÄÎßå ÏÉàÎ°úÏö¥ Íµ¨Ï°∞) ===
app.post('/api/pets', async (req, res) => {
  console.log('üêï Î∞òÎ†§Í≤¨ Îì±Î°ù ÏöîÏ≤≠:', req.body)
  const { user_id, name, breed, personality, birth_date, special_notes } = req.body || {}
  
  if (!user_id || !name) {
    return res.status(400).json({ 
      success: false, 
      message: 'ÏÇ¨Ïö©Ïûê IDÏôÄ Î∞òÎ†§Í≤¨ Ïù¥Î¶ÑÏùÄ ÌïÑÏàòÏûÖÎãàÎã§.' 
    })
  }

  try {
    const dog = await createDog({
      user_id,
      name,
      breed: breed || 'ÌíàÏ¢Ö ÎØ∏ÌôïÏù∏',
      personality: personality || '',
      birth_date: birth_date || null,
      special_notes: special_notes || ''
    })

    console.log('‚úÖ Î∞òÎ†§Í≤¨ Îì±Î°ù ÏÑ±Í≥µ:', dog)
    
    res.status(201).json({
      success: true,
      data: {
        dog_id: dog.dog_id || dog.id,
        name: dog.name,
        breed: dog.breed,
        message: 'Î∞òÎ†§Í≤¨Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Îì±Î°ùÎêòÏóàÏäµÎãàÎã§.'
      }
    })
  } catch (error) {
    console.error('‚ùå Î∞òÎ†§Í≤¨ Îì±Î°ù Ïã§Ìå®:', error)
    res.status(500).json({
      success: false,
      message: 'Î∞òÎ†§Í≤¨ Îì±Î°ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.',
      error: error.message
    })
  }
})

app.get('/api/pets/user/:userId', async (req, res) => {
  console.log('üêï ÏÇ¨Ïö©Ïûê Î∞òÎ†§Í≤¨ Î™©Î°ù Ï°∞Ìöå:', req.params.userId)
  const { userId } = req.params
  
  try {
    const dogs = await getDogsByUserId(userId)
    console.log('‚úÖ Î∞òÎ†§Í≤¨ Î™©Î°ù Ï°∞Ìöå ÏÑ±Í≥µ:', dogs)
    
    res.json({
      success: true,
      data: dogs
    })
  } catch (error) {
    console.error('‚ùå Î∞òÎ†§Í≤¨ Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®:', error)
    res.status(500).json({
      success: false,
      message: 'Î∞òÎ†§Í≤¨ Î™©Î°ù Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.',
      error: error.message
    })
  }
})

// ÎîîÎ≤ÑÍπÖÏö©: ÏÇ¨Ïö©Ïûê Î™©Î°ù Ï°∞Ìöå
app.get('/api/debug/users', async (req, res) => {
  try {
    const [rows] = await pool.execute('SELECT * FROM users LIMIT 10')
    res.json({
      success: true,
      data: rows
    })
  } catch (error) {
    console.error('‚ùå ÏÇ¨Ïö©Ïûê Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®:', error)
    res.status(500).json({
      success: false,
      error: error.message
    })
  }
})

// === Conversations (Mongo) ===
// ÎåÄÌôî ÏÉùÏÑ± ÎòêÎäî Ï°∞Ìöå (participantsÎäî Î¨∏ÏûêÏó¥ ID Î∞∞Ïó¥)
app.post('/api/conversations', async (req, res) => {
  try {
    const { participantIds } = req.body || {}
    if (!Array.isArray(participantIds) || participantIds.length < 2) {
      return res.status(400).json({ success: false, message: 'participantIds(2Î™Ö Ïù¥ÏÉÅ)Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.' })
    }
    const participants = [...new Set(participantIds.map(String))].sort()
    let conv = await Conversation.findOne({ participants }).lean()
    if (!conv) {
      const created = await Conversation.create({ participants, lastMessageAt: new Date(0) })
      conv = created.toObject()
    }
    return res.json({ success: true, data: { conversationId: String(conv._id), participants: conv.participants, lastMessageText: conv.lastMessageText || '', lastMessageAt: conv.lastMessageAt } })
  } catch (e) {
    console.error('create/get conversation error', e)
    res.status(500).json({ success: false, message: 'ÎåÄÌôî ÏÉùÏÑ± Ïã§Ìå®' })
  }
})

// ÏÇ¨Ïö©ÏûêÏùò ÎåÄÌôî Î™©Î°ù Ï°∞Ìöå
app.get('/api/conversations', async (req, res) => {
  const { userId } = req.query
  if (!userId) return res.status(400).json({ success: false, message: 'userId ÌïÑÏöî' })
  try {
    const list = await Conversation.find({ participants: String(userId) })
      .sort({ lastMessageAt: -1 })
      .lean()

    // Ï∞∏Ïó¨Ïûê Ïù¥Î©îÏùº Îß§Ìïë (ÏÉÅÎåÄÎ∞©Îßå ÌëúÏãú)
    const otherIds = Array.from(new Set(list
      .map(c => (c.participants || []).find(p => String(p) !== String(userId)))
      .filter(Boolean)
      .map(String)))

    let idHas = false, userIdHas = false, fullNameHas = false
    try {
      const [cols] = await pool.execute('SHOW COLUMNS FROM users')
      const names = cols.map(c => c.Field)
      idHas = names.includes('id')
      userIdHas = names.includes('user_id')
      fullNameHas = names.includes('full_name')
    } catch {}

    const emailMap = new Map()
    const nameMap = new Map()
    if (otherIds.length > 0 && (idHas || userIdHas)) {
      if (idHas && userIdHas) {
        const [rows] = await pool.execute(
          `SELECT ${idHas ? 'id' : 'NULL'} AS id, ${userIdHas ? 'user_id' : 'NULL'} AS user_id, email, ${fullNameHas ? 'full_name' : 'NULL'} AS full_name FROM users 
           WHERE ${idHas ? 'id IN (?)' : '1=0'} OR ${userIdHas ? 'user_id IN (?)' : '1=0'}`,
          [otherIds, otherIds]
        )
        for (const r of rows) {
          if (r.id != null) emailMap.set(String(r.id), r.email)
          if (r.user_id != null) emailMap.set(String(r.user_id), r.email)
          if (r.id != null) nameMap.set(String(r.id), r.full_name)
          if (r.user_id != null) nameMap.set(String(r.user_id), r.full_name)
        }
      } else if (idHas) {
        const [rows] = await pool.execute(`SELECT id, email, ${fullNameHas ? 'full_name' : 'NULL'} AS full_name FROM users WHERE id IN (?)`, [otherIds])
        for (const r of rows) { emailMap.set(String(r.id), r.email); nameMap.set(String(r.id), r.full_name) }
      } else if (userIdHas) {
        const [rows] = await pool.execute(`SELECT user_id, email, ${fullNameHas ? 'full_name' : 'NULL'} AS full_name FROM users WHERE user_id IN (?)`, [otherIds])
        for (const r of rows) { emailMap.set(String(r.user_id), r.email); nameMap.set(String(r.user_id), r.full_name) }
      }
    }

    const data = list.map(c => {
      const other = (c.participants || []).find(p => String(p) !== String(userId))
      const email = other ? (emailMap.get(String(other)) || null) : null
      const fullName = other ? (nameMap.get(String(other)) || null) : null
      const displayName = (c.lastMessageSenderName || null) || email || fullName || (other ? String(other) : null)
      return {
        id: String(c._id),
        participants: c.participants,
        otherId: other ? String(other) : null,
        otherEmail: email,
        otherFullName: fullName,
        lastMessageSenderName: c.lastMessageSenderName || null,
        displayName,
        lastMessageText: c.lastMessageText || '',
        lastMessageAt: c.lastMessageAt || null,
      }
    })
    return res.json({ success: true, data })
  } catch (e) {
    console.error('list conversations error', e)
    res.status(500).json({ success: false, message: 'ÎåÄÌôî Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®' })
  }
})

// ÎåÄÌôî ÏÇ≠Ï†ú (ÎåÄÌôîÏôÄ Í¥ÄÎ†® Î©îÏãúÏßÄ Î™®Îëê Ï†úÍ±∞)
app.delete('/api/conversations/:conversationId', async (req, res) => {
  const { conversationId } = req.params
  try {
    await Message.deleteMany({ conversationId })
    const result = await Conversation.deleteOne({ _id: conversationId })
    return res.json({ success: result.deletedCount > 0 })
  } catch (e) {
    console.error('delete conversation error', e)
    res.status(500).json({ success: false, message: 'ÎåÄÌôî ÏÇ≠Ï†ú Ïã§Ìå®' })
  }
})

// === Bookings ===
// Í≤¨Ï£º ÏòàÏïΩ Î™©Î°ù Ï°∞Ìöå (Í∞ÄÍπåÏö¥ ÏãúÍ∞Ñ Ïàú)
app.get('/api/bookings/owner/:ownerId', async (req, res) => {
  try {
    const rows = await getBookingsByOwnerId(String(req.params.ownerId))
    // Ï†ïÎ†¨ Î≥¥Ïû• (DB Ï†ïÎ†¨ Ïã§Ìå® ÎåÄÎπÑ)
    const sorted = [...(rows || [])].sort((a, b) => new Date(a.start_time) - new Date(b.start_time))
    res.json({ success: true, bookings: sorted })
  } catch (e) {
    console.error('bookings list error', e)
    res.status(500).json({ success: false, message: 'ÏòàÏïΩ Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®' })
  }
})

// ÏòàÏïΩ ÏÉùÏÑ± (ÏãúÌÑ∞ Í≥µÍ≥† Í∏∞Ï§ÄÏúºÎ°ú ÏÉùÏÑ± Í∞ÄÎä•)
app.post('/api/bookings', async (req, res) => {
  const { owner_id, sitter_id, dog_id, start_time, end_time, source_post_id } = req.body || {}
  if (!owner_id || !sitter_id || !dog_id || !start_time || !end_time) {
    return res.status(400).json({ success: false, message: 'ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ (owner_id, sitter_id, dog_id, start_time, end_time)' })
  }
  try {
    console.log('üì¶ booking payload:', { owner_id, sitter_id, dog_id, start_time, end_time, source_post_id })
    let location = undefined
    if (source_post_id) {
      try {
        const pool = require('mysql2/promise').createPool(require('./config/database-minimal').dbConfig)
        const [rows] = await pool.execute(`SELECT location FROM sitter_postings WHERE post_id = ? LIMIT 1`, [source_post_id])
        location = rows?.[0]?.location || undefined
      } catch {}
    }
    const hourlyRate = Number(process.env.DEFAULT_HOURLY_RATE || 0)
    const result = await createBooking({ owner_id, sitter_id, dog_id, start_time, end_time, location, hourly_rate: hourlyRate })
    // ÎåÄÌôîÎ∞© ÏûêÎèô ÏÉùÏÑ±/Î≥¥Ïû• (Mongo)
    try {
      const participants = [String(owner_id), String(sitter_id)].sort()
      let conv = await Conversation.findOne({ participants })
      if (!conv) {
        conv = await Conversation.create({ participants, lastMessageAt: new Date(0) })
      }
    } catch (e) {
      console.warn('ensure conversation warn:', e?.message)
    }
    // ÏòàÏïΩ ÏÑ±Í≥µ Ïãú, Í¥ÄÎ†® ÏãúÌÑ∞ Í≥µÍ≥† Îã´Í∏∞
    if (source_post_id) {
      try {
        const pool = require('mysql2/promise').createPool(require('./config/database-minimal').dbConfig)
        await pool.execute(`UPDATE sitter_postings SET status='closed' WHERE post_id = ?`, [source_post_id])
      } catch (e) {
        console.warn('sitter posting close warn:', e?.message)
      }
    }
    return res.json({ success: true, booking_id: result.bookingId })
  } catch (e) {
    console.error('booking create error', e)
    res.status(500).json({ success: false, message: e?.message || 'ÏòàÏïΩ ÏÉùÏÑ± Ïã§Ìå®' })
  }
})

// ÏòàÏïΩ ÏÇ≠Ï†ú API
app.delete('/api/bookings/:bookingId', async (req, res) => {
  const { bookingId } = req.params
  const { user_id } = req.query
  
  if (!bookingId || !user_id) {
    return res.status(400).json({ 
      success: false, 
      message: 'ÌïÑÏàò ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§. (bookingId, user_id)' 
    });
  }

  try {
    console.log(`üóëÔ∏è ÏòàÏïΩ ÏÇ≠Ï†ú ÏöîÏ≤≠: bookingId=${bookingId}, userId=${user_id}`);
    
    // ÏòàÏïΩ Ï†ïÎ≥¥ Ï°∞Ìöå Î∞è Í∂åÌïú ÌôïÏù∏
    const pool = require('mysql2/promise').createPool(require('./config/database-minimal').dbConfig)
    const [rows] = await pool.execute(
      `SELECT * FROM bookings WHERE booking_id = ? AND owner_id = ? LIMIT 1`, 
      [bookingId, user_id]
    )
    
    if (!rows || rows.length === 0) {
      return res.status(404).json({ 
        success: false, 
        message: 'ÏòàÏïΩÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÍ±∞ÎÇò ÏÇ≠Ï†ú Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.' 
      });
    }
    
    // ÏòàÏïΩ ÏÇ≠Ï†ú (Ïã§Ï†úÎ°úÎäî ÏÉÅÌÉúÎ•º 'cancelled'Î°ú Î≥ÄÍ≤Ω)
    const [result] = await pool.execute(
      `UPDATE bookings SET status = 'cancelled', updated_at = NOW() WHERE booking_id = ? AND owner_id = ?`,
      [bookingId, user_id]
    )
    
    if (result.affectedRows > 0) {
      console.log('‚úÖ ÏòàÏïΩ ÏÇ≠Ï†ú ÏÑ±Í≥µ');
      res.json({ success: true, message: 'ÏòàÏïΩÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.' });
    } else {
      res.status(404).json({ success: false, message: 'ÏòàÏïΩ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.' });
    }
    
  } catch (error) {
    console.error('‚ùå ÏòàÏïΩ ÏÇ≠Ï†ú Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      error: 'ÏòàÏïΩ ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
    });
  }
});

// ÎåÄÌôîÎ∞© Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå (MongoDB)
app.get('/api/conversations/:conversationId/messages', async (req, res) => {
  const { conversationId } = req.params
  const { before, limit = 30 } = req.query
  try {
    const q = { conversationId }
    if (before) q.createdAt = { $lt: new Date(String(before)) }
    const items = await Message.find(q)
      .sort({ createdAt: -1 })
      .limit(Math.min(Number(limit) || 30, 100))
      .lean()
    res.json({ success: true, data: items.reverse() })
  } catch (e) {
    console.error('Query messages error', e)
    res.status(500).json({ success: false, error: 'Failed to fetch messages' })
  }
})

// === Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå ===
// S3 URLÎ°ú ÏµúÏã† Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå
app.get('/api/dog-analysis/by-url', async (req, res) => {
  const { s3Url } = req.query
  
  if (!s3Url) {
    return res.status(400).json({ 
      success: false, 
      error: 's3Url ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§' 
    })
  }

  try {
    console.log('üîç Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå ÏöîÏ≤≠:', s3Url)
    const { getLatestAnalysisByS3Url, getLatestAnalysisByFilename } = require('./config/database-minimal')
    
    // 1Ï∞®: S3 URLÎ°ú Ï†ïÌôïÌûà Í≤ÄÏÉâ
    let analysis = await getLatestAnalysisByS3Url(s3Url)
    console.log('üìä S3 URL Í≤ÄÏÉâ Í≤∞Í≥º:', analysis)
    
    // 2Ï∞®: S3 URLÏóêÏÑú ÌååÏùºÎ™Ö Ï∂îÏ∂úÌï¥ÏÑú Í≤ÄÏÉâ
    if (!analysis) {
      const fileName = s3Url.split('/').pop() // URLÏóêÏÑú ÌååÏùºÎ™Ö Ï∂îÏ∂ú
      console.log('üîç ÌååÏùºÎ™ÖÏúºÎ°ú Ïû¨Í≤ÄÏÉâ:', fileName)
      analysis = await getLatestAnalysisByFilename(fileName)
      console.log('üìä ÌååÏùºÎ™Ö Í≤ÄÏÉâ Í≤∞Í≥º:', analysis)
    }
    
    // 3Ï∞®: ÏµúÏã† Î∂ÑÏÑù Í≤∞Í≥º Ï§ëÏóêÏÑú Ïú†ÏÇ¨Ìïú ÏãúÍ∞ÑÎåÄ Í≤ÄÏÉâ (ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Í∏∞Î∞ò)
    if (!analysis) {
      const timestamp = s3Url.match(/(\d{13})/)?.[1] // URLÏóêÏÑú ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Ï∂îÏ∂ú
      if (timestamp) {
        console.log('üîç ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÎ°ú Í≤ÄÏÉâ:', timestamp)
        const { pool } = require('./config/database-minimal')
        const [rows] = await pool.execute(
          'SELECT * FROM dog_analyses WHERE file_name LIKE ? ORDER BY created_at DESC LIMIT 1',
          [`%${timestamp}%`]
        )
        analysis = rows.length > 0 ? rows[0] : null
        console.log('üìä ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Í≤ÄÏÉâ Í≤∞Í≥º:', analysis)
      }
    }
    
    if (!analysis) {
      console.log('‚ùå Î∂ÑÏÑù Í≤∞Í≥º ÏóÜÏùå - S3 URL:', s3Url)
      return res.json({
        success: false,
        message: 'Ìï¥Îãπ Ïù¥ÎØ∏ÏßÄÏóê ÎåÄÌïú Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§'
      })
    }

    // Î∂ÑÏÑù Í≤∞Í≥º Î∞òÌôò (ÌíàÏ¢ÖÍ≥º DBTI Ï†ïÎ≥¥)
    const responseData = {
      success: true,
      data: {
        recognizedBreed: analysis.recognized_breed,
        confidence: analysis.confidence,
        dbtiType: analysis.dbti_type,
        dbtiName: analysis.dbti_name,
        dbtiDescription: analysis.dbti_description,
        createdAt: analysis.created_at
      }
    }
    console.log('‚úÖ API ÏùëÎãµ Îç∞Ïù¥ÌÑ∞:', responseData)
    res.json(responseData)
  } catch (e) {
    console.error('‚ùå Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå Ïã§Ìå®:', e)
    res.status(500).json({ 
      success: false, 
      error: `Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå Ïã§Ìå®: ${e.message}` 
    })
  }
})

// ÌååÏùºÎ™ÖÏúºÎ°ú Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå
app.get('/api/dog-analysis/by-filename', async (req, res) => {
  const { fileName } = req.query
  
  if (!fileName) {
    return res.status(400).json({ 
      success: false, 
      error: 'fileName ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§' 
    })
  }

  try {
    const { getLatestAnalysisByFilename } = require('./config/database-minimal')
    const analysis = await getLatestAnalysisByFilename(fileName)
    
    if (!analysis) {
      return res.json({
        success: false,
        message: 'Ìï¥Îãπ ÌååÏùºÏóê ÎåÄÌïú Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§'
      })
    }

    res.json({
      success: true,
      data: {
        recognizedBreed: analysis.recognized_breed,
        confidence: analysis.confidence,
        dbtiType: analysis.dbti_type,
        dbtiName: analysis.dbti_name,
        dbtiDescription: analysis.dbti_description,
        createdAt: analysis.created_at
      }
    })
  } catch (e) {
    console.error('‚ùå Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå Ïã§Ìå®:', e)
    res.status(500).json({ 
      success: false, 
      error: `Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå Ïã§Ìå®: ${e.message}` 
    })
  }
})

// S3 ÏÇ¨Ï†ÑÏÑúÎ™Ö URL Î∞úÍ∏â
app.post('/api/uploads/sign', async (req, res) => {
  const { fileName, contentType } = req.body || {}
  
  if (!fileName || !contentType) {
    return res.status(400).json({ 
      success: false, 
      error: 'fileNameÍ≥º contentTypeÏù¥ ÌïÑÏöîÌï©ÎãàÎã§' 
    })
  }

  // AWS ÏûêÍ≤© Ï¶ùÎ™Ö ÌôïÏù∏
  if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY) {
    console.error('‚ùå AWS ÏûêÍ≤© Ï¶ùÎ™ÖÏù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§')
    return res.status(500).json({
      success: false,
      error: 'AWS ÏûêÍ≤© Ï¶ùÎ™ÖÏù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§'
    })
  }

  try {
    // test0812 Ìè¥ÎçîÏóê Ï†ÄÏû•
    const key = `test0812/${Date.now()}_${fileName}`
    const command = new PutObjectCommand({ 
      Bucket: s3Bucket, 
      Key: key, 
      ContentType: contentType 
    })
    
    // ÏÇ¨Ï†ÑÏÑúÎ™Ö URL ÏÉùÏÑ± (5Î∂Ñ ÎßåÎ£å)
    const uploadUrl = await getSignedUrl(s3, command, { expiresIn: 300 })
    const publicUrl = `https://${s3Bucket}.s3.${REGION}.amazonaws.com/${key}`
    
    console.log('‚úÖ S3 ÏÇ¨Ï†ÑÏÑúÎ™Ö URL ÏÉùÏÑ± ÏÑ±Í≥µ:', { key, publicUrl })
    
    res.json({ 
      success: true, 
      uploadUrl, 
      key, 
      publicUrl 
    })
  } catch (e) {
    console.error('‚ùå S3 ÏÇ¨Ï†ÑÏÑúÎ™Ö URL ÏÉùÏÑ± Ïã§Ìå®:', e)
    res.status(500).json({ 
      success: false, 
      error: `S3 ÏÇ¨Ï†ÑÏÑúÎ™Ö URL ÏÉùÏÑ± Ïã§Ìå®: ${e.message}` 
    })
  }
})

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî Ìï®Ïàò Ï†úÍ±∞
// MongoDB Î∞è MySQL ÏùòÏ°¥ÏÑ± Ï†úÍ±∞Îê®

// Socket.IO Ïó∞Í≤∞ Ï≤òÎ¶¨
io.on('connection', (socket) => {
  console.log('ÏÇ¨Ïö©Ïûê Ïó∞Í≤∞Îê®:', socket.id)

  // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï†ÄÏû•
  socket.on('user:join', (userData) => {
    activeUsers.set(socket.id, userData)
    console.log('ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Îì±Î°ù:', userData)
  })

  // ÎåÄÌôîÎ∞© Ï∞∏Í∞Ä
  socket.on('conversation:join', (conversationId) => {
    socket.join(conversationId)
    console.log(`ÏÇ¨Ïö©Ïûê ${socket.id}Í∞Ä ÎåÄÌôîÎ∞© ${conversationId}Ïóê Ï∞∏Í∞Ä`)
    
    // ÎåÄÌôîÎ∞©Ïùò Í∏∞Ï°¥ Î©îÏãúÏßÄ ÌûàÏä§ÌÜ†Î¶¨ Ï†ÑÏÜ°
    const messages = messageHistory.get(conversationId) || []
    socket.emit('messages:history', messages)
  })

  // ÎåÄÌôîÎ∞© ÎÇòÍ∞ÄÍ∏∞
  socket.on('conversation:leave', (conversationId) => {
    socket.leave(conversationId)
    console.log(`ÏÇ¨Ïö©Ïûê ${socket.id}Í∞Ä ÎåÄÌôîÎ∞© ${conversationId}ÏóêÏÑú ÎÇòÍ∞ê`)
  })

  // Î©îÏãúÏßÄ Ï†ÑÏÜ° (MongoDB Ï†ÄÏû•)
  socket.on('message:send', async (data) => {
    const { conversationId, message, senderId, senderName, type = 'text', imageUri, fileName, fileSize } = data
    
    const newMessage = {
      conversationId,
      senderId,
      senderName,
      type,
      content: message,
      createdAt: new Date(),
      readBy: [{
        userId: senderId,
        readAt: new Date()
      }]
    }

    // Ïù¥ÎØ∏ÏßÄÎÇò ÌååÏùºÏùò Í≤ΩÏö∞ Ï∂îÍ∞Ä Ï†ïÎ≥¥ Ìè¨Ìï®
    if (type === 'image' && imageUri) {
      newMessage.imageUri = imageUri
    } else if (type === 'file' && fileName) {
      newMessage.fileName = fileName
      newMessage.fileSize = fileSize
    }

    try {
      const saved = await Message.create(newMessage)
      await Conversation.updateOne({ _id: conversationId }, {
        lastMessageText: newMessage.type === 'text' ? newMessage.content : newMessage.type,
        lastMessageAt: new Date(),
        lastMessageSenderName: newMessage.senderName || '',
      }, { upsert: true })

      // ÎåÄÌôîÎ∞©Ïùò Î™®Îì† ÏÇ¨Ïö©ÏûêÏóêÍ≤å Î©îÏãúÏßÄ Ï†ÑÏÜ°
      io.to(conversationId).emit('message:received', {
        id: String(saved._id),
        ...newMessage,
        createdAt: saved.createdAt.toISOString(),
      })
      
      console.log(`ÎåÄÌôîÎ∞© ${conversationId}ÏóêÏÑú Î©îÏãúÏßÄ Ï†ÑÏÜ°:`, newMessage.content)
      
    } catch (error) {
      console.error('Î©îÏãúÏßÄ Ï†ÄÏû• Ïò§Î•ò:', error)
      socket.emit('message:error', { error: 'Î©îÏãúÏßÄ Ï†ÑÏÜ°Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.' })
    }
  })

  // Î©îÏãúÏßÄ ÏùΩÏùå Ï≤òÎ¶¨
  socket.on('message:read', (data) => {
    const { conversationId, messageId, userId } = data
    
    const messages = messageHistory.get(conversationId) || []
    const message = messages.find(m => m.id === messageId)
    
    if (message && !message.readBy.includes(userId)) {
      message.readBy.push(userId)
      
      // ÎåÄÌôîÎ∞©Ïùò Îã§Î•∏ ÏÇ¨Ïö©ÏûêÎì§ÏóêÍ≤å ÏùΩÏùå ÏÉÅÌÉú ÏïåÎ¶º
      socket.to(conversationId).emit('message:read_updated', {
        messageId,
        readBy: message.readBy
      })
    }
  })

  // ÌÉÄÏù¥Ìïë ÏÉÅÌÉú
  socket.on('typing:start', (data) => {
    const { conversationId, userId, userName } = data
    socket.to(conversationId).emit('typing:user_started', { userId, userName })
  })

  socket.on('typing:stop', (data) => {
    const { conversationId, userId } = data
    socket.to(conversationId).emit('typing:user_stopped', { userId })
  })

  // Ïó∞Í≤∞ Ìï¥Ï†ú
  socket.on('disconnect', () => {
    const userData = activeUsers.get(socket.id)
    activeUsers.delete(socket.id)
    console.log('ÏÇ¨Ïö©Ïûê Ïó∞Í≤∞ Ìï¥Ï†ú:', socket.id, userData?.name || 'Unknown')
  })
})

const PORT = process.env.PORT || 3001

console.log('[boot] starting http server on', PORT)
server.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ Pet Buddy ServerÍ∞Ä Ìè¨Ìä∏ ${PORT}ÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§!`)
  console.log(`üí¨ Socket.IO ÏÑúÎ≤ÑÍ∞Ä ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§.`)
  console.log(`üåê ÏÑúÎ≤Ñ Ï£ºÏÜå: http://localhost:${PORT}`)
  console.log(`üìã API Î¨∏ÏÑú: http://localhost:${PORT}/`)
});

// Mongo Ïó∞Í≤∞ÏùÄ Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú ÏãúÎèÑ (ÏÑúÎ≤Ñ Í∏∞ÎèôÍ≥º Î¨¥Í¥Ä)
(async () => {
  try {
    console.log('[boot] connecting to Mongo...')
    await connectMongo(process.env.MONGODB_URI)
    console.log('üçÉ MongoDB Ïó∞Í≤∞ ÏôÑÎ£å')
  } catch (e) {
    console.warn('üçÉ MongoDB Ïó∞Í≤∞ Í≤ΩÍ≥†:', e?.message)
  }
})()

